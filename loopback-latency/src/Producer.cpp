/*
 * Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "Producer.h"
#include "Console.h"

#define DEBUG_FRAMES 0

Producer::Producer(const TestFormat& format, size_t simulatedProcessing)
    : m_format(format)
    , m_simulatedProcessing(simulatedProcessing)
    , m_streaming(false)
    , m_currentFrame(0)
{
}

Producer::~Producer()
{
    if (m_streaming)
        StopStreaming();
}

const TestFormat& Producer::Format() const
{
    return m_format;
}

bool Producer::StartStreaming()
{
    m_streaming = true;
    m_streamThread = std::thread(StreamThreadStatic, this);

    return true;
}

void Producer::StopStreaming()
{
    m_streaming = false;
    m_streamThread.join();
}

bool Producer::IsStreaming() const
{
    return m_streaming;
}

std::shared_ptr<Frame> Producer::GetFrame(const void* ptr)
{
    // Determine the color of the buffer being looked up.
    uint8_t r = ((uint8_t*)ptr)[0];
    uint8_t g = ((uint8_t*)ptr)[1];
    uint8_t b = ((uint8_t*)ptr)[2];

    std::lock_guard<std::mutex> lock(m_framesMutex);
#if DEBUG_FRAMES
    Log("Received frame: " << (int)r << ", " << (int)g << ", " << (int)b);
#endif
    for (auto it = m_frames.begin(); it != m_frames.end();)
    {
        // Allow a fuzzy compare of the color to account for minor color differences.
        if (FuzzyMatch(*it, r, g, b, 1))
        {
            // Return the frame if it matches.
            return *it;
        }
        else
        {
            // If it doesn't match, we assume that we received a later frame so
            // we remove this frame from the list so its color can be reused.
            it = m_frames.erase(it);
        }
    }

    Error("Could not find frame color (" << (int)r << "," << (int)g << "," << (int)b <<
          ") in producer records." << std::endl <<
          "This means that the consumer received a frame color that was never" << std::endl <<
          "generated by the producer. This could be caused by a general producer" << std::endl <<
          "and/or consumer error, but it could also be caused by the loopback" << std::endl <<
          "cable not being connected properly to the required device ports." << std::endl <<
          "Please check the cable connections and try again.");

    return std::shared_ptr<Frame>(nullptr);
}

std::shared_ptr<Frame> Producer::StartFrame()
{
    auto frame(std::make_shared<Frame>(m_currentFrame++));
    std::lock_guard<std::mutex> lock(m_framesMutex);
#if DEBUG_FRAMES
    Log("Starting frame: " << (int)frame->R() << ", " << (int)frame->G() << ", " << (int)frame->B());
#endif
    m_frames.push_back(frame);
    return frame;
}

bool Producer::FuzzyMatch(const std::shared_ptr<Frame>& frame,
        uint8_t r, uint8_t g, uint8_t b, uint8_t threshold)
{
    return (std::abs(frame->R() - r) <= threshold &&
            std::abs(frame->G() - g) <= threshold &&
            std::abs(frame->B() - b) <= threshold);
}

void Producer::StreamThreadStatic(Producer* producer)
{
    producer->StreamThread();
}

std::ostream& operator<<(std::ostream& o, const Producer& p)
{
    return p.Dump(o);
}
